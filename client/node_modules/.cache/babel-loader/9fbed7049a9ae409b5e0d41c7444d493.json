{"ast":null,"code":"export { i as context } from './index-deps.js';\nimport { c as commonjsGlobal, p as parse_1, l as lib$2, a as lib$3, j as jsonParse } from './fetch-deps.js';\nimport { _ as __awaiter, d as devUtils, p as parseBody, g as getPublicUrlFromRequest, N as NetworkError } from './RequestHandler-deps.js';\nexport { R as RequestHandler, f as cleanUrl, e as compose, c as createResponseComposition, b as defaultContext, a as defaultResponse, m as matchRequestUrl, r as response } from './RequestHandler-deps.js';\nimport { store } from '@mswjs/cookies';\nimport { i as isStringEqual, R as RestHandler } from './rest-deps.js';\nexport { a as RESTMethods, R as RestHandler, r as rest, b as restContext } from './rest-deps.js';\nimport { t as tryCatch, p as parseGraphQLRequest, G as GraphQLHandler } from './graphql-deps.js';\nexport { G as GraphQLHandler, g as graphql, a as graphqlContext } from './graphql-deps.js';\nimport { m as mergeRight } from './errors-deps.js';\nimport { createInterceptor } from '@mswjs/interceptors';\nimport { interceptFetch } from '@mswjs/interceptors/lib/interceptors/fetch';\nimport { interceptXMLHttpRequest } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest';\nimport './xml-deps.js';\nimport '@mswjs/interceptors/lib/utils/getCleanUrl';\nvar lib$1 = {};\nvar StrictEventEmitter$1 = {};\nvar events = {\n  exports: {}\n};\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\n\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\nevents.exports = EventEmitter;\nevents.exports.once = once; // Backwards-compat with node 0.10.x\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    } // At least give some kind of context to the user\n\n\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    } // Check for listener leak\n\n\n    m = _getMaxListeners(target);\n\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true; // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n\n      resolve([].slice.call(arguments));\n    }\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\nvar __extends = commonjsGlobal && commonjsGlobal.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nStrictEventEmitter$1.__esModule = true;\nStrictEventEmitter$1.StrictEventEmitter = void 0;\nvar events_1 = events.exports;\n\nvar StrictEventEmitter =\n/** @class */\nfunction (_super) {\n  __extends(StrictEventEmitter, _super);\n\n  function StrictEventEmitter() {\n    return _super.call(this) || this;\n  }\n\n  StrictEventEmitter.prototype.on = function (event, listener) {\n    return _super.prototype.on.call(this, event.toString(), listener);\n  };\n\n  StrictEventEmitter.prototype.once = function (event, listener) {\n    return _super.prototype.on.call(this, event.toString(), listener);\n  };\n\n  StrictEventEmitter.prototype.off = function (event, listener) {\n    return _super.prototype.off.call(this, event.toString(), listener);\n  };\n\n  StrictEventEmitter.prototype.emit = function (event) {\n    var data = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      data[_i - 1] = arguments[_i];\n    }\n\n    return _super.prototype.emit.apply(this, __spreadArrays([event.toString()], data));\n  };\n\n  StrictEventEmitter.prototype.addListener = function (event, listener) {\n    return _super.prototype.addListener.call(this, event.toString(), listener);\n  };\n\n  StrictEventEmitter.prototype.removeListener = function (event, listener) {\n    return _super.prototype.removeListener.call(this, event.toString(), listener);\n  };\n\n  return StrictEventEmitter;\n}(events_1.EventEmitter);\n\nStrictEventEmitter$1.StrictEventEmitter = StrictEventEmitter;\n\n(function (exports) {\n  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    });\n  } : function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n\n  exports.__esModule = true;\n  exports.StrictEventEmitter = void 0;\n  var StrictEventEmitter_1 = StrictEventEmitter$1;\n\n  __createBinding(exports, StrictEventEmitter_1, \"StrictEventEmitter\");\n})(lib$1);\n\nvar lib = {};\nvar until$1 = {};\nObject.defineProperty(until$1, \"__esModule\", {\n  value: true\n});\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * cosnt [error, data] = await until(() => asyncAction())\n */\n\nuntil$1.until = async promise => {\n  try {\n    const data = await promise().catch(error => {\n      throw error;\n    });\n    return [null, data];\n  } catch (error) {\n    return [error, null];\n  }\n};\n\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\nvar until_1 = until$1;\nvar until = lib.until = until_1.until;\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\n\nconst getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n}\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\n\n\nconst getWorkerInstance = function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    // Resolve the absolute Service Worker URL.\n    const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n    const mockRegistrations = yield navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n\n    if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n      // Reload the page when it has associated workers, but no active controller.\n      // The absence of a controller can mean either:\n      // - page has no Service Worker associated with it\n      // - page has been hard-reloaded and its workers won't be used until the next reload.\n      // Since we've checked that there are registrations associated with this page,\n      // at this point we are sure it's hard reload that falls into this clause.\n      location.reload();\n    }\n\n    const [existingRegistration] = mockRegistrations;\n\n    if (existingRegistration) {\n      // When the Service Worker is registered, update it and return the reference.\n      return existingRegistration.update().then(() => {\n        return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n      });\n    } // When the Service Worker wasn't found, register it anew and return the reference.\n\n\n    const [error, instance] = yield until(() => __awaiter(void 0, void 0, void 0, function* () {\n      const registration = yield navigator.serviceWorker.register(url, options);\n      return [// Compare existing worker registration by its worker URL,\n      // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n      getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n    })); // Handle Service Worker registration errors.\n\n    if (error) {\n      const isWorkerMissing = error.message.includes('(404)'); // Produce a custom error message when given a non-existing Service Worker url.\n      // Suggest developers to check their setup.\n\n      if (isWorkerMissing) {\n        const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\n        throw new Error(devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n      } // Fallback error message for any other registration errors.\n\n\n      throw new Error(devUtils.formatMessage('Failed to register the Service Worker:\\n\\n%s', error.message));\n    }\n\n    return instance;\n  });\n};\n/**\r\n * Prints a worker activation message in the browser's console.\r\n */\n\n\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  const message = args.message || 'Mocking enabled.';\n  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, 'color:orangered;font-weight:bold;');\n  console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\n  console.log('Found an issue? https://github.com/mswjs/msw/issues');\n  console.groupEnd();\n}\n/**\r\n * Signals the worker to enable the interception of requests.\r\n */\n\n\nfunction enableMocking(context, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    context.workerChannel.send('MOCK_ACTIVATE');\n    return context.events.once('MOCKING_ENABLED').then(() => {\n      printStartMessage({\n        quiet: options.quiet\n      });\n    });\n  });\n}\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\n\n\nconst createBroadcastChannel = event => {\n  const port = event.ports[0];\n  return {\n    /**\r\n     * Sends a text message to the connected Service Worker.\r\n     */\n    send(message) {\n      if (port) {\n        port.postMessage(message);\n      }\n    }\n\n  };\n};\n\nfunction getAllCookies() {\n  return parse_1(document.cookie);\n}\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\n\n\nfunction getRequestCookies(request) {\n  /**\r\n   * @note No cookies persist on the document in Node.js: no document.\r\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {};\n  }\n\n  switch (request.credentials) {\n    case 'same-origin':\n      {\n        // Return document cookies only when requested a resource\n        // from the same origin as the current document.\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n\n    case 'include':\n      {\n        // Return all document cookies.\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n}\n/**\r\n * Sets relevant cookies on the request.\r\n * Request cookies are taken from the following sources:\r\n * - Immediate (own) request cookies (those in the \"Cookie\" request header);\r\n * - From the `document.cookie` based on the request's `credentials` value;\r\n * - From the internal cookie store that persists/hydrates cookies in Node.js\r\n */\n\n\nfunction setRequestCookies(request) {\n  var _a; // Set mocked request cookies from the `cookie` header of the original request.\n  // No need to take `credentials` into account, because in Node.js requests are intercepted\n  // _after_ they happen. Request issuer should have already taken care of sending relevant cookies.\n  // Unlike browser, where interception is on the worker level, _before_ the request happens.\n\n\n  const requestCookiesString = request.headers.get('cookie');\n  store.hydrate();\n  const cookiesFromStore = Array.from((_a = store.get(Object.assign(Object.assign({}, request), {\n    url: request.url.toString()\n  }))) === null || _a === void 0 ? void 0 : _a.entries()).reduce((cookies, _ref) => {\n    let [name, {\n      value\n    }] = _ref;\n    return Object.assign(cookies, {\n      [name.trim()]: value\n    });\n  }, {});\n  const cookiesFromDocument = getRequestCookies(request);\n  const forwardedCookies = Object.assign(Object.assign({}, cookiesFromDocument), cookiesFromStore); // Ensure the persisted (document) cookies are propagated to the request.\n  // Propagated the cookies persisted in the Cookuie Store to the request headers.\n  // This forwards relevant request cookies based on the request's credentials.\n\n  for (const [name, value] of Object.entries(forwardedCookies)) {\n    request.headers.append('cookie', `${name}=${value}`);\n  }\n\n  const ownCookies = requestCookiesString ? parse_1(requestCookiesString) : {};\n  request.cookies = Object.assign(Object.assign(Object.assign({}, request.cookies), forwardedCookies), ownCookies);\n}\n/**\r\n * Ensures that an empty GET request body is always represented as `undefined`.\r\n */\n\n\nfunction pruneGetRequestBody(request) {\n  if (request.method && isStringEqual(request.method, 'GET') && request.body === '') {\n    return undefined;\n  }\n\n  return request.body;\n}\n/**\r\n * Converts a given request received from the Service Worker\r\n * into a `MockedRequest` instance.\r\n */\n\n\nfunction parseWorkerRequest(rawRequest) {\n  const request = {\n    id: rawRequest.id,\n    cache: rawRequest.cache,\n    credentials: rawRequest.credentials,\n    method: rawRequest.method,\n    url: new URL(rawRequest.url),\n    referrer: rawRequest.referrer,\n    referrerPolicy: rawRequest.referrerPolicy,\n    redirect: rawRequest.redirect,\n    mode: rawRequest.mode,\n    params: {},\n    cookies: {},\n    integrity: rawRequest.integrity,\n    keepalive: rawRequest.keepalive,\n    destination: rawRequest.destination,\n    body: pruneGetRequestBody(rawRequest),\n    bodyUsed: rawRequest.bodyUsed,\n    headers: new lib$2.Headers(rawRequest.headers)\n  }; // Set document cookies on the request.\n\n  setRequestCookies(request); // Parse the request's body based on the \"Content-Type\" header.\n\n  request.body = parseBody(request.body, request.headers);\n  return request;\n}\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\n\n\nconst getResponse = (request, handlers, resolutionContext) => __awaiter(void 0, void 0, void 0, function* () {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined\n    };\n  }\n\n  const result = yield relevantHandlers.reduce((executionResult, handler) => __awaiter(void 0, void 0, void 0, function* () {\n    const previousResults = yield executionResult;\n\n    if (!!(previousResults === null || previousResults === void 0 ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n\n    const result = yield handler.run(request, resolutionContext);\n\n    if (result === null || result.handler.shouldSkip) {\n      return null;\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult\n      };\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true);\n    }\n\n    return result;\n  }), Promise.resolve(null)); // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined\n    };\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n});\n\nvar jsLevenshtein = function () {\n  function _min(d0, d1, d2, bx, ay) {\n    return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n  }\n\n  return function (a, b) {\n    if (a === b) {\n      return 0;\n    }\n\n    if (a.length > b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var la = a.length;\n    var lb = b.length;\n\n    while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n      la--;\n      lb--;\n    }\n\n    var offset = 0;\n\n    while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n      offset++;\n    }\n\n    la -= offset;\n    lb -= offset;\n\n    if (la === 0 || lb < 3) {\n      return lb;\n    }\n\n    var x = 0;\n    var y;\n    var d0;\n    var d1;\n    var d2;\n    var d3;\n    var dd;\n    var dy;\n    var ay;\n    var bx0;\n    var bx1;\n    var bx2;\n    var bx3;\n    var vector = [];\n\n    for (y = 0; y < la; y++) {\n      vector.push(y + 1);\n      vector.push(a.charCodeAt(offset + y));\n    }\n\n    var len = vector.length - 1;\n\n    for (; x < lb - 3;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      bx1 = b.charCodeAt(offset + (d1 = x + 1));\n      bx2 = b.charCodeAt(offset + (d2 = x + 2));\n      bx3 = b.charCodeAt(offset + (d3 = x + 3));\n      dd = x += 4;\n\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        ay = vector[y + 1];\n        d0 = _min(dy, d0, d1, bx0, ay);\n        d1 = _min(d0, d1, d2, bx1, ay);\n        d2 = _min(d1, d2, d3, bx2, ay);\n        dd = _min(d2, d3, dd, bx3, ay);\n        vector[y] = dd;\n        d3 = d2;\n        d2 = d1;\n        d1 = d0;\n        d0 = dy;\n      }\n    }\n\n    for (; x < lb;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      dd = ++x;\n\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n        d0 = dy;\n      }\n    }\n\n    return dd;\n  };\n}();\n\nconst MAX_MATCH_SCORE = 3;\nconst MAX_SUGGESTION_COUNT = 4;\nconst TYPE_MATCH_DELTA = 0.5;\n\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\n\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method); // Always treat a handler with the same method as a more similar one.\n\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = jsLevenshtein(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\n\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity;\n    }\n\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n\n    if (typeof operationName !== 'string') {\n      return Infinity;\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType; // Always treat a handler with the same operation type as a more similar one.\n\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = jsLevenshtein(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\n\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref2, _ref3) => {\n    let [leftScore] = _ref2;\n    let [rightScore] = _ref3;\n    return leftScore - rightScore;\n  }).filter(_ref4 => {\n    let [score] = _ref4;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref5 => {\n    let [, handler] = _ref5;\n    return handler;\n  });\n  return suggestedHandlers;\n}\n\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  • ${handler.info.header}`).join('\\n')}`;\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\n\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'warn';\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n\n  function generateHandlerSuggestion() {\n    /**\r\n     * @note Ignore exceptions during GraphQL request parsing because at this point\r\n     * we cannot assume the unhandled request is a valid GraphQL request.\r\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\r\n     */\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : '';\n  }\n\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`].filter(Boolean);\n    return messageTemplate.join('\\n\\n');\n  }\n\n  function applyStrategy(strategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage();\n\n    switch (strategy) {\n      case 'error':\n        {\n          // Print a developer-friendly error.\n          devUtils.error('Error: %s', message); // Throw an exception to halt request processing and not perform the original request.\n\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n\n      case 'warn':\n        {\n          devUtils.warn('Warning: %s', message);\n          break;\n        }\n\n      case 'bypass':\n        break;\n\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy));\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error')\n    });\n    return;\n  }\n\n  applyStrategy(strategy);\n}\n\nfunction readResponseCookies(request, response) {\n  store.add(Object.assign(Object.assign({}, request), {\n    url: request.url.toString()\n  }), response);\n  store.persist();\n}\n\nfunction handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    emitter.emit('request:start', request); // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n\n    if (request.headers.get('x-msw-bypass') === 'true') {\n      emitter.emit('request:end', request);\n      (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, request);\n      return;\n    } // Resolve a mocked response from the list of request handlers.\n\n\n    const lookupResult = yield getResponse(request, handlers, handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.resolutionContext);\n    const {\n      handler,\n      response\n    } = lookupResult; // When there's no handler for the request, consider it unhandled.\n    // Allow the developer to react to such cases.\n\n    if (!handler) {\n      onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n      emitter.emit('request:unhandled', request);\n      emitter.emit('request:end', request);\n      (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, request);\n      return;\n    } // When the handled request returned no mocked response, warn the developer,\n    // as it may be an oversight on their part. Perform the request as-is.\n\n\n    if (!response) {\n      devUtils.warn(`\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`, response, handler.info.header, handler.info.callFrame);\n      emitter.emit('request:end', request);\n      (_c = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _c === void 0 ? void 0 : _c.call(handleRequestOptions, request);\n      return;\n    } // Store all the received response cookies in the virtual cookie store.\n\n\n    readResponseCookies(request, response);\n    emitter.emit('request:match', request);\n    return new Promise(resolve => {\n      var _a, _b, _c;\n\n      const requiredLookupResult = lookupResult;\n      const transformedResponse = ((_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.transformResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, response)) || response;\n      (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n      setTimeout(() => {\n        var _a;\n\n        (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponseSent) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n        emitter.emit('request:end', request);\n        resolve(transformedResponse);\n      }, (_c = response.delay) !== null && _c !== void 0 ? _c : 0);\n    });\n  });\n}\n\nconst createRequestListener = (context, options) => {\n  return (event, message) => __awaiter(void 0, void 0, void 0, function* () {\n    const channel = createBroadcastChannel(event);\n\n    try {\n      const request = parseWorkerRequest(message.payload);\n      yield handleRequest(request, context.requestHandlers, options, context.emitter, {\n        transformResponse(response) {\n          return Object.assign(Object.assign({}, response), {\n            headers: response.headers.all()\n          });\n        },\n\n        onBypassResponse() {\n          return channel.send({\n            type: 'MOCK_NOT_FOUND'\n          });\n        },\n\n        onMockedResponse(response) {\n          channel.send({\n            type: 'MOCK_SUCCESS',\n            payload: response\n          });\n        },\n\n        onMockedResponseSent(response, _ref6) {\n          let {\n            handler,\n            publicRequest,\n            parsedRequest\n          } = _ref6;\n\n          if (!options.quiet) {\n            handler.log(publicRequest, response, handler, parsedRequest);\n          }\n        }\n\n      });\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        return channel.send({\n          type: 'NETWORK_ERROR',\n          payload: {\n            name: error.name,\n            message: error.message\n          }\n        });\n      } // Treat all the other exceptions in a request handler\n      // as unintended, alerting that there is a problem needs fixing.\n\n\n      channel.send({\n        type: 'INTERNAL_ERROR',\n        payload: {\n          status: 500,\n          body: JSON.stringify({\n            errorType: error.constructor.name,\n            message: error.message,\n            location: error.stack\n          })\n        }\n      });\n    }\n  });\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Signal Service Worker to report back its integrity\n    context.workerChannel.send('INTEGRITY_CHECK_REQUEST');\n    const {\n      payload: actualChecksum\n    } = yield context.events.once('INTEGRITY_CHECK_RESPONSE'); // Compare the response from the Service Worker and the\n    // global variable set by Rollup during the build.\n\n    if (actualChecksum !== \"02f4ad4a2797f85668baf196e553d929\") {\n      throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"02f4ad4a2797f85668baf196e553d929\"}).`);\n    }\n\n    return serviceWorker;\n  });\n}\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\n\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  var _this = this;\n\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  }; // Defer any `fetch` requests until the Service Worker is ready.\n\n\n  const originalFetch = window.fetch;\n\n  window.fetch = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return __awaiter(_this, void 0, void 0, function* () {\n      yield until(() => predicatePromise);\n      window.fetch = originalFetch;\n      return window.fetch(...args);\n    });\n  };\n}\n\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n\n    const {\n      payload: responseJson\n    } = message;\n    /**\r\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\r\n     * That kind of responses cannot be manipulated in JavaScript due\r\n     * to the security considerations.\r\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\r\n     * @see https://github.com/mswjs/msw/issues/529\r\n     */\n\n    if ((_a = responseJson.type) === null || _a === void 0 ? void 0 : _a.includes('opaque')) {\n      return;\n    }\n\n    const response = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw';\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId);\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId);\n    }\n  };\n}\n\nfunction validateWorkerScope(registration, options) {\n  if (!(options === null || options === void 0 ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(`\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`);\n  }\n}\n\nconst createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners(); // Handle requests signaled by the worker.\n\n      context.workerChannel.on('REQUEST', createRequestListener(context, options));\n      context.workerChannel.on('RESPONSE', createResponseListener(context));\n      const instance = yield getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n\n      if (!worker) {\n        const missingWorkerMessage = (customOptions === null || customOptions === void 0 ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED');\n        } // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n\n\n        window.clearInterval(context.keepAliveInterval);\n      }); // Check if the active Service Worker is the latest published one\n\n      const [integrityError] = yield until(() => requestIntegrityCheck(context, worker));\n\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `);\n      }\n\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send('KEEPALIVE_REQUEST'), 5000); // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    });\n\n    const workerRegistration = startWorkerInstance().then(registration => __awaiter(this, void 0, void 0, function* () {\n      const pendingInstance = registration.installing || registration.waiting; // Wait until the worker is activated.\n      // Assume the worker is already activated if there's no pending registration\n      // (i.e. when reloading the page after a successful activation).\n\n      if (pendingInstance) {\n        yield new Promise(resolve => {\n          pendingInstance.addEventListener('statechange', () => {\n            if (pendingInstance.state === 'activated') {\n              return resolve();\n            }\n          });\n        });\n      } // Print the activation message only after the worker has been activated.\n\n\n      yield enableMocking(context, options).catch(error => {\n        throw new Error(`Failed to enable mocking: ${error === null || error === void 0 ? void 0 : error.message}`);\n      });\n      return registration;\n    })); // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n};\n\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  console.log(`%c${devUtils.formatMessage('Mocking disabled.')}`, 'color:orangered;font-weight:bold;');\n}\n\nconst createStop = context => {\n  return function stop() {\n    var _a;\n    /**\r\n     * Signal the Service Worker to disable mocking for this client.\r\n     * Use this an an explicit way to stop the mocking, while preserving\r\n     * the worker-client relation. Does not affect the worker's lifecycle.\r\n     */\n\n\n    context.workerChannel.send('MOCK_DEACTIVATE');\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) === null || _a === void 0 ? void 0 : _a.quiet\n    });\n  };\n};\n\nfunction use(currentHandlers) {\n  for (var _len3 = arguments.length, handlers = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    handlers[_key3 - 1] = arguments[_key3];\n  }\n\n  currentHandlers.unshift(...handlers);\n}\n\nfunction restoreHandlers(handlers) {\n  handlers.forEach(handler => {\n    handler.markAsSkipped(false);\n  });\n}\n\nfunction resetHandlers(initialHandlers) {\n  for (var _len4 = arguments.length, nextHandlers = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    nextHandlers[_key4 - 1] = arguments[_key4];\n  }\n\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\n}\n\nconst DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n\n};\n/**\r\n * Returns resolved worker start options, merging the default options\r\n * with the given custom options.\r\n */\n\nfunction resolveStartOptions(initialOptions) {\n  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\n}\n\nfunction prepareStartHandler(handler, context) {\n  return initialOptions => {\n    context.startOptions = resolveStartOptions(initialOptions);\n    return handler(context.startOptions, initialOptions || {});\n  };\n}\n/**\r\n * Converts a given isomorphic request to a `MockedRequest` instance.\r\n */\n\n\nfunction parseIsomorphicRequest(request) {\n  const mockedRequest = {\n    id: request.id,\n    url: request.url,\n    method: request.method,\n    body: parseBody(request.body, request.headers),\n    credentials: request.credentials || 'same-origin',\n    headers: request.headers,\n    cookies: {},\n    redirect: 'manual',\n    referrer: '',\n    keepalive: false,\n    cache: 'default',\n    mode: 'cors',\n    referrerPolicy: 'no-referrer',\n    integrity: '',\n    destination: 'document',\n    bodyUsed: false\n  }; // Attach all the cookies from the virtual cookie store.\n\n  setRequestCookies(mockedRequest);\n  return mockedRequest;\n}\n\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = createInterceptor({\n    modules: [interceptFetch, interceptXMLHttpRequest],\n\n    resolver(request) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const mockedRequest = parseIsomorphicRequest(request);\n        return handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n          transformResponse(response) {\n            return {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers.all(),\n              body: response.body\n            };\n          },\n\n          onMockedResponseSent(response, _ref7) {\n            let {\n              handler,\n              publicRequest,\n              parsedRequest\n            } = _ref7;\n\n            if (!options.quiet) {\n              handler.log(publicRequest, response, handler, parsedRequest);\n            }\n          }\n\n        });\n      });\n    }\n\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\nfunction createFallbackStart(context) {\n  return function start(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      context.fallbackInterceptor = createFallbackRequestListener(context, options);\n      printStartMessage({\n        message: 'Mocking enabled (fallback mode).',\n        quiet: options.quiet\n      });\n      return undefined;\n    });\n  };\n}\n\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n\n    (_a = context.fallbackInterceptor) === null || _a === void 0 ? void 0 : _a.restore();\n    printStopMessage({\n      quiet: (_b = context.startOptions) === null || _b === void 0 ? void 0 : _b.quiet\n    });\n  };\n}\n/**\r\n * Pipes all emitted events from one emitter to another.\r\n */\n\n\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit; // @ts-ignore\n\n  if (rawEmit._isPiped) {\n    return;\n  }\n\n  source.emit = function (event) {\n    for (var _len5 = arguments.length, data = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      data[_key5 - 1] = arguments[_key5];\n    }\n\n    destination.emit(event, ...data);\n    return rawEmit.call(this, event, ...data);\n  }; // @ts-ignore\n\n\n  source.emit._isPiped = true;\n} // Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\n\n\nlet listeners = [];\n/**\r\n * Creates a new mock Service Worker registration\r\n * with the given request handlers.\r\n * @param {RequestHandler[]} requestHandlers List of request handlers\r\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\r\n */\n\nfunction setupWorker() {\n  for (var _len6 = arguments.length, requestHandlers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    requestHandlers[_key6] = arguments[_key6];\n  }\n\n  requestHandlers.forEach(handler => {\n    if (Array.isArray(handler)) throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\n  }); // Error when attempting to run this function in a Node.js environment.\n\n  if (lib$3.exports.isNodeProcess()) {\n    throw new Error(devUtils.formatMessage('Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.'));\n  }\n\n  const emitter = new lib$1.StrictEventEmitter();\n  const publicEmitter = new lib$1.StrictEventEmitter();\n  pipeEvents(emitter, publicEmitter);\n  const context = {\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, 'message', event => {\n          // Avoid messages broadcasted from unrelated workers.\n          if (event.source !== context.worker) {\n            return;\n          }\n\n          const message = jsonParse(event.data);\n\n          if (!message) {\n            return;\n          }\n\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n\n      send(type) {\n        var _a;\n\n        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage(type);\n      }\n\n    },\n    events: {\n      addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType,\n          target,\n          callback\n        });\n        return () => {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n\n      removeAllListeners() {\n        for (const {\n          target,\n          eventType,\n          callback\n        } of listeners) {\n          target.removeEventListener(eventType, callback);\n        }\n\n        listeners = [];\n      },\n\n      once(eventType) {\n        const bindings = [];\n        return new Promise((resolve, reject) => {\n          const handleIncomingMessage = event => {\n            try {\n              const message = JSON.parse(event.data);\n\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error) {\n              reject(error);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\n        }).finally(() => {\n          bindings.forEach(unbind => unbind());\n        });\n      }\n\n    },\n    useFallbackMode: !('serviceWorker' in navigator) || location.protocol === 'file:'\n  };\n  const startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n  const stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n  return {\n    start: prepareStartHandler(startHandler, context),\n\n    stop() {\n      context.events.removeAllListeners();\n      context.emitter.removeAllListeners();\n      publicEmitter.removeAllListeners();\n      stopHandler();\n    },\n\n    use() {\n      for (var _len7 = arguments.length, handlers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        handlers[_key7] = arguments[_key7];\n      }\n\n      use(context.requestHandlers, ...handlers);\n    },\n\n    restoreHandlers() {\n      restoreHandlers(context.requestHandlers);\n    },\n\n    resetHandlers() {\n      for (var _len8 = arguments.length, nextHandlers = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        nextHandlers[_key8] = arguments[_key8];\n      }\n\n      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\n    },\n\n    printHandlers() {\n      context.requestHandlers.forEach(handler => {\n        const {\n          header,\n          callFrame\n        } = handler.info;\n        const pragma = handler.info.hasOwnProperty('operationType') ? '[graphql]' : '[rest]';\n        console.groupCollapsed(`${pragma} ${header}`);\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`);\n        }\n\n        console.log('Handler:', handler);\n\n        if (handler instanceof RestHandler) {\n          console.log('Match:', `https://mswjs.io/repl?path=${handler.info.path}`);\n        }\n\n        console.groupEnd();\n      });\n    },\n\n    events: {\n      on() {\n        return publicEmitter.on(...arguments);\n      },\n\n      removeListener() {\n        return publicEmitter.removeListener(...arguments);\n      },\n\n      removeAllListeners() {\n        return publicEmitter.removeAllListeners(...arguments);\n      }\n\n    }\n  };\n}\n\nexport { handleRequest, parseIsomorphicRequest, setupWorker };","map":{"version":3,"sources":["/Users/chritsophersarmiento/git/my-portfolio/client/node_modules/msw/lib/esm/index.js"],"names":["i","context","c","commonjsGlobal","p","parse_1","l","lib$2","a","lib$3","j","jsonParse","_","__awaiter","d","devUtils","parseBody","g","getPublicUrlFromRequest","N","NetworkError","R","RequestHandler","f","cleanUrl","e","compose","createResponseComposition","b","defaultContext","defaultResponse","m","matchRequestUrl","r","response","store","isStringEqual","RestHandler","RESTMethods","rest","restContext","t","tryCatch","parseGraphQLRequest","G","GraphQLHandler","graphql","graphqlContext","mergeRight","createInterceptor","interceptFetch","interceptXMLHttpRequest","lib$1","StrictEventEmitter$1","events","exports","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ReflectOwnKeys","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","ProcessEmitWarning","warning","console","warn","NumberIsNaN","Number","isNaN","value","EventEmitter","init","once","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","create","setMaxListeners","n","_getMaxListeners","that","getMaxListeners","emit","type","arguments","length","push","doError","error","er","Error","err","message","handler","len","listeners","arrayClone","_addListener","prepend","existing","newListener","unshift","warned","w","String","name","emitter","count","addListener","on","prependListener","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","prependOnceListener","list","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","key","_listeners","unwrap","evlistener","unwrapListeners","rawListeners","listenerCount","eventNames","arr","copy","Array","index","pop","ret","Promise","resolve","reject","errorListener","resolver","slice","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","addEventListener","wrapListener","removeEventListener","__extends","extendStatics","setPrototypeOf","__proto__","hasOwnProperty","__","constructor","__spreadArrays","s","il","k","jl","__esModule","StrictEventEmitter","events_1","_super","event","toString","data","_i","__createBinding","o","k2","StrictEventEmitter_1","lib","until$1","until","promise","catch","until_1","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","getAbsoluteWorkerUrl","relativeUrl","URL","location","origin","href","getWorkerInstance","url","options","mockRegistrations","navigator","serviceWorker","getRegistrations","then","registrations","controller","reload","existingRegistration","update","instance","register","isWorkerMissing","includes","scopeUrl","scope","formatMessage","printStartMessage","quiet","groupCollapsed","log","groupEnd","enableMocking","workerChannel","send","createBroadcastChannel","port","ports","postMessage","getAllCookies","document","cookie","getRequestCookies","request","credentials","setRequestCookies","_a","requestCookiesString","headers","hydrate","cookiesFromStore","from","assign","entries","reduce","cookies","trim","cookiesFromDocument","forwardedCookies","append","ownCookies","pruneGetRequestBody","method","body","parseWorkerRequest","rawRequest","id","cache","referrer","referrerPolicy","redirect","mode","params","integrity","keepalive","destination","bodyUsed","Headers","getResponse","handlers","resolutionContext","relevantHandlers","test","result","executionResult","previousResults","run","shouldSkip","parsedResult","markAsSkipped","publicRequest","parsedRequest","jsLevenshtein","_min","d0","d1","d2","bx","ay","tmp","la","lb","charCodeAt","offset","x","y","d3","dd","dy","bx0","bx1","bx2","bx3","vector","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groupHandlersByType","groups","getRestHandlerScore","path","info","RegExp","Infinity","hasSameMethod","methodScoreDelta","requestPublicUrl","score","getGraphQLHandlerScore","parsedQuery","operationName","operationType","hasSameOperationType","operationTypeScoreDelta","getSuggestedHandler","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","map","getSuggestedHandlersMessage","header","join","onUnhandledRequest","strategy","parsedGraphQLQuery","generateHandlerSuggestion","handlerGroups","generateUnhandledRequestMessage","publicUrl","requestHeader","handlerSuggestion","messageTemplate","applyStrategy","readResponseCookies","add","persist","handleRequest","handleRequestOptions","_b","_c","onBypassResponse","lookupResult","callFrame","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","setTimeout","onMockedResponseSent","delay","createRequestListener","channel","payload","requestHandlers","all","status","JSON","stringify","errorType","stack","requestIntegrityCheck","actualChecksum","deferNetworkRequestsUntil","predicatePromise","originalXhrSend","window","XMLHttpRequest","originalFetch","fetch","createResponseListener","responseJson","Response","isMockedResponse","requestId","validateWorkerScope","startsWith","createStartHandler","start","customOptions","startWorkerInstance","missingWorkerMessage","host","clearInterval","keepAliveInterval","integrityError","setInterval","startOptions","workerRegistration","pendingInstance","waitUntilReady","printStopMessage","createStop","stop","use","currentHandlers","restoreHandlers","forEach","resetHandlers","initialHandlers","nextHandlers","DEFAULT_START_OPTIONS","mockServiceWorkerUrl","resolveStartOptions","initialOptions","prepareStartHandler","parseIsomorphicRequest","mockedRequest","createFallbackRequestListener","interceptor","modules","statusText","createFallbackStart","fallbackInterceptor","createFallbackStop","restore","pipeEvents","source","rawEmit","_isPiped","setupWorker","isArray","isNodeProcess","publicEmitter","eventType","callback","bindings","handleIncomingMessage","parse","finally","unbind","useFallbackMode","protocol","startHandler","stopHandler","printHandlers","pragma"],"mappings":"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","sourcesContent":["export { i as context } from './index-deps.js';\nimport { c as commonjsGlobal, p as parse_1, l as lib$2, a as lib$3, j as jsonParse } from './fetch-deps.js';\nimport { _ as __awaiter, d as devUtils, p as parseBody, g as getPublicUrlFromRequest, N as NetworkError } from './RequestHandler-deps.js';\nexport { R as RequestHandler, f as cleanUrl, e as compose, c as createResponseComposition, b as defaultContext, a as defaultResponse, m as matchRequestUrl, r as response } from './RequestHandler-deps.js';\nimport { store } from '@mswjs/cookies';\nimport { i as isStringEqual, R as RestHandler } from './rest-deps.js';\nexport { a as RESTMethods, R as RestHandler, r as rest, b as restContext } from './rest-deps.js';\nimport { t as tryCatch, p as parseGraphQLRequest, G as GraphQLHandler } from './graphql-deps.js';\nexport { G as GraphQLHandler, g as graphql, a as graphqlContext } from './graphql-deps.js';\nimport { m as mergeRight } from './errors-deps.js';\nimport { createInterceptor } from '@mswjs/interceptors';\nimport { interceptFetch } from '@mswjs/interceptors/lib/interceptors/fetch';\nimport { interceptXMLHttpRequest } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest';\nimport './xml-deps.js';\nimport '@mswjs/interceptors/lib/utils/getCleanUrl';\n\nvar lib$1 = {};\n\nvar StrictEventEmitter$1 = {};\n\nvar events = {exports: {}};\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (commonjsGlobal && commonjsGlobal.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nStrictEventEmitter$1.__esModule = true;\nStrictEventEmitter$1.StrictEventEmitter = void 0;\nvar events_1 = events.exports;\nvar StrictEventEmitter = /** @class */ (function (_super) {\n    __extends(StrictEventEmitter, _super);\n    function StrictEventEmitter() {\n        return _super.call(this) || this;\n    }\n    StrictEventEmitter.prototype.on = function (event, listener) {\n        return _super.prototype.on.call(this, event.toString(), listener);\n    };\n    StrictEventEmitter.prototype.once = function (event, listener) {\n        return _super.prototype.on.call(this, event.toString(), listener);\n    };\n    StrictEventEmitter.prototype.off = function (event, listener) {\n        return _super.prototype.off.call(this, event.toString(), listener);\n    };\n    StrictEventEmitter.prototype.emit = function (event) {\n        var data = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            data[_i - 1] = arguments[_i];\n        }\n        return _super.prototype.emit.apply(this, __spreadArrays([event.toString()], data));\n    };\n    StrictEventEmitter.prototype.addListener = function (event, listener) {\n        return _super.prototype.addListener.call(this, event.toString(), listener);\n    };\n    StrictEventEmitter.prototype.removeListener = function (event, listener) {\n        return _super.prototype.removeListener.call(this, event.toString(), listener);\n    };\n    return StrictEventEmitter;\n}(events_1.EventEmitter));\nStrictEventEmitter$1.StrictEventEmitter = StrictEventEmitter;\n\n(function (exports) {\nvar __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nexports.__esModule = true;\nexports.StrictEventEmitter = void 0;\nvar StrictEventEmitter_1 = StrictEventEmitter$1;\n__createBinding(exports, StrictEventEmitter_1, \"StrictEventEmitter\");\n}(lib$1));\n\nvar lib = {};\n\nvar until$1 = {};\n\nObject.defineProperty(until$1, \"__esModule\", { value: true });\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * cosnt [error, data] = await until(() => asyncAction())\n */\nuntil$1.until = async (promise) => {\n    try {\n        const data = await promise().catch((error) => {\n            throw error;\n        });\n        return [null, data];\n    }\n    catch (error) {\n        return [error, null];\n    }\n};\n\nObject.defineProperty(lib, \"__esModule\", { value: true });\nvar until_1 = until$1;\nvar until = lib.until = until_1.until;\n\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\r\nconst getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\r\n    const allStates = [\r\n        registration.active,\r\n        registration.installing,\r\n        registration.waiting,\r\n    ];\r\n    const existingStates = allStates.filter(Boolean);\r\n    const mockWorker = existingStates.find((worker) => {\r\n        return findWorker(worker.scriptURL, absoluteWorkerUrl);\r\n    });\r\n    return mockWorker || null;\r\n};\n\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\r\nfunction getAbsoluteWorkerUrl(relativeUrl) {\r\n    return new URL(relativeUrl, location.origin).href;\r\n}\n\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\r\nconst getWorkerInstance = (url, options = {}, findWorker) => __awaiter(void 0, void 0, void 0, function* () {\r\n    // Resolve the absolute Service Worker URL.\r\n    const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\r\n    const mockRegistrations = yield navigator.serviceWorker\r\n        .getRegistrations()\r\n        .then((registrations) => registrations.filter((registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\r\n    if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\r\n        // Reload the page when it has associated workers, but no active controller.\r\n        // The absence of a controller can mean either:\r\n        // - page has no Service Worker associated with it\r\n        // - page has been hard-reloaded and its workers won't be used until the next reload.\r\n        // Since we've checked that there are registrations associated with this page,\r\n        // at this point we are sure it's hard reload that falls into this clause.\r\n        location.reload();\r\n    }\r\n    const [existingRegistration] = mockRegistrations;\r\n    if (existingRegistration) {\r\n        // When the Service Worker is registered, update it and return the reference.\r\n        return existingRegistration.update().then(() => {\r\n            return [\r\n                getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker),\r\n                existingRegistration,\r\n            ];\r\n        });\r\n    }\r\n    // When the Service Worker wasn't found, register it anew and return the reference.\r\n    const [error, instance] = yield until(() => __awaiter(void 0, void 0, void 0, function* () {\r\n        const registration = yield navigator.serviceWorker.register(url, options);\r\n        return [\r\n            // Compare existing worker registration by its worker URL,\r\n            // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\r\n            getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\r\n            registration,\r\n        ];\r\n    }));\r\n    // Handle Service Worker registration errors.\r\n    if (error) {\r\n        const isWorkerMissing = error.message.includes('(404)');\r\n        // Produce a custom error message when given a non-existing Service Worker url.\r\n        // Suggest developers to check their setup.\r\n        if (isWorkerMissing) {\r\n            const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\r\n            throw new Error(devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\r\n        }\r\n        // Fallback error message for any other registration errors.\r\n        throw new Error(devUtils.formatMessage('Failed to register the Service Worker:\\n\\n%s', error.message));\r\n    }\r\n    return instance;\r\n});\n\n/**\r\n * Prints a worker activation message in the browser's console.\r\n */\r\nfunction printStartMessage(args = {}) {\r\n    if (args.quiet) {\r\n        return;\r\n    }\r\n    const message = args.message || 'Mocking enabled.';\r\n    console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, 'color:orangered;font-weight:bold;');\r\n    console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\r\n    console.log('Found an issue? https://github.com/mswjs/msw/issues');\r\n    console.groupEnd();\r\n}\n\n/**\r\n * Signals the worker to enable the interception of requests.\r\n */\r\nfunction enableMocking(context, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        context.workerChannel.send('MOCK_ACTIVATE');\r\n        return context.events.once('MOCKING_ENABLED').then(() => {\r\n            printStartMessage({ quiet: options.quiet });\r\n        });\r\n    });\r\n}\n\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\r\nconst createBroadcastChannel = (event) => {\r\n    const port = event.ports[0];\r\n    return {\r\n        /**\r\n         * Sends a text message to the connected Service Worker.\r\n         */\r\n        send(message) {\r\n            if (port) {\r\n                port.postMessage(message);\r\n            }\r\n        },\r\n    };\r\n};\n\nfunction getAllCookies() {\r\n    return parse_1(document.cookie);\r\n}\r\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\r\nfunction getRequestCookies(request) {\r\n    /**\r\n     * @note No cookies persist on the document in Node.js: no document.\r\n     */\r\n    if (typeof document === 'undefined' || typeof location === 'undefined') {\r\n        return {};\r\n    }\r\n    switch (request.credentials) {\r\n        case 'same-origin': {\r\n            // Return document cookies only when requested a resource\r\n            // from the same origin as the current document.\r\n            return location.origin === request.url.origin ? getAllCookies() : {};\r\n        }\r\n        case 'include': {\r\n            // Return all document cookies.\r\n            return getAllCookies();\r\n        }\r\n        default: {\r\n            return {};\r\n        }\r\n    }\r\n}\n\n/**\r\n * Sets relevant cookies on the request.\r\n * Request cookies are taken from the following sources:\r\n * - Immediate (own) request cookies (those in the \"Cookie\" request header);\r\n * - From the `document.cookie` based on the request's `credentials` value;\r\n * - From the internal cookie store that persists/hydrates cookies in Node.js\r\n */\r\nfunction setRequestCookies(request) {\r\n    var _a;\r\n    // Set mocked request cookies from the `cookie` header of the original request.\r\n    // No need to take `credentials` into account, because in Node.js requests are intercepted\r\n    // _after_ they happen. Request issuer should have already taken care of sending relevant cookies.\r\n    // Unlike browser, where interception is on the worker level, _before_ the request happens.\r\n    const requestCookiesString = request.headers.get('cookie');\r\n    store.hydrate();\r\n    const cookiesFromStore = Array.from((_a = store.get(Object.assign(Object.assign({}, request), { url: request.url.toString() }))) === null || _a === void 0 ? void 0 : _a.entries()).reduce((cookies, [name, { value }]) => {\r\n        return Object.assign(cookies, { [name.trim()]: value });\r\n    }, {});\r\n    const cookiesFromDocument = getRequestCookies(request);\r\n    const forwardedCookies = Object.assign(Object.assign({}, cookiesFromDocument), cookiesFromStore);\r\n    // Ensure the persisted (document) cookies are propagated to the request.\r\n    // Propagated the cookies persisted in the Cookuie Store to the request headers.\r\n    // This forwards relevant request cookies based on the request's credentials.\r\n    for (const [name, value] of Object.entries(forwardedCookies)) {\r\n        request.headers.append('cookie', `${name}=${value}`);\r\n    }\r\n    const ownCookies = requestCookiesString\r\n        ? parse_1(requestCookiesString)\r\n        : {};\r\n    request.cookies = Object.assign(Object.assign(Object.assign({}, request.cookies), forwardedCookies), ownCookies);\r\n}\n\n/**\r\n * Ensures that an empty GET request body is always represented as `undefined`.\r\n */\r\nfunction pruneGetRequestBody(request) {\r\n    if (request.method &&\r\n        isStringEqual(request.method, 'GET') &&\r\n        request.body === '') {\r\n        return undefined;\r\n    }\r\n    return request.body;\r\n}\n\n/**\r\n * Converts a given request received from the Service Worker\r\n * into a `MockedRequest` instance.\r\n */\r\nfunction parseWorkerRequest(rawRequest) {\r\n    const request = {\r\n        id: rawRequest.id,\r\n        cache: rawRequest.cache,\r\n        credentials: rawRequest.credentials,\r\n        method: rawRequest.method,\r\n        url: new URL(rawRequest.url),\r\n        referrer: rawRequest.referrer,\r\n        referrerPolicy: rawRequest.referrerPolicy,\r\n        redirect: rawRequest.redirect,\r\n        mode: rawRequest.mode,\r\n        params: {},\r\n        cookies: {},\r\n        integrity: rawRequest.integrity,\r\n        keepalive: rawRequest.keepalive,\r\n        destination: rawRequest.destination,\r\n        body: pruneGetRequestBody(rawRequest),\r\n        bodyUsed: rawRequest.bodyUsed,\r\n        headers: new lib$2.Headers(rawRequest.headers),\r\n    };\r\n    // Set document cookies on the request.\r\n    setRequestCookies(request);\r\n    // Parse the request's body based on the \"Content-Type\" header.\r\n    request.body = parseBody(request.body, request.headers);\r\n    return request;\r\n}\n\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\r\nconst getResponse = (request, handlers, resolutionContext) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const relevantHandlers = handlers.filter((handler) => {\r\n        return handler.test(request, resolutionContext);\r\n    });\r\n    if (relevantHandlers.length === 0) {\r\n        return {\r\n            handler: undefined,\r\n            response: undefined,\r\n        };\r\n    }\r\n    const result = yield relevantHandlers.reduce((executionResult, handler) => __awaiter(void 0, void 0, void 0, function* () {\r\n        const previousResults = yield executionResult;\r\n        if (!!(previousResults === null || previousResults === void 0 ? void 0 : previousResults.response)) {\r\n            return executionResult;\r\n        }\r\n        const result = yield handler.run(request, resolutionContext);\r\n        if (result === null || result.handler.shouldSkip) {\r\n            return null;\r\n        }\r\n        if (!result.response) {\r\n            return {\r\n                request: result.request,\r\n                handler: result.handler,\r\n                response: undefined,\r\n                parsedResult: result.parsedResult,\r\n            };\r\n        }\r\n        if (result.response.once) {\r\n            handler.markAsSkipped(true);\r\n        }\r\n        return result;\r\n    }), Promise.resolve(null));\r\n    // Although reducing a list of relevant request handlers, it's possible\r\n    // that in the end there will be no handler associted with the request\r\n    // (i.e. if relevant handlers are fall-through).\r\n    if (!result) {\r\n        return {\r\n            handler: undefined,\r\n            response: undefined,\r\n        };\r\n    }\r\n    return {\r\n        handler: result.handler,\r\n        publicRequest: result.request,\r\n        parsedRequest: result.parsedResult,\r\n        response: result.response,\r\n    };\r\n});\n\nvar jsLevenshtein = (function()\n{\n  function _min(d0, d1, d2, bx, ay)\n  {\n    return d0 < d1 || d2 < d1\n        ? d0 > d2\n            ? d2 + 1\n            : d0 + 1\n        : bx === ay\n            ? d1\n            : d1 + 1;\n  }\n\n  return function(a, b)\n  {\n    if (a === b) {\n      return 0;\n    }\n\n    if (a.length > b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var la = a.length;\n    var lb = b.length;\n\n    while (la > 0 && (a.charCodeAt(la - 1) === b.charCodeAt(lb - 1))) {\n      la--;\n      lb--;\n    }\n\n    var offset = 0;\n\n    while (offset < la && (a.charCodeAt(offset) === b.charCodeAt(offset))) {\n      offset++;\n    }\n\n    la -= offset;\n    lb -= offset;\n\n    if (la === 0 || lb < 3) {\n      return lb;\n    }\n\n    var x = 0;\n    var y;\n    var d0;\n    var d1;\n    var d2;\n    var d3;\n    var dd;\n    var dy;\n    var ay;\n    var bx0;\n    var bx1;\n    var bx2;\n    var bx3;\n\n    var vector = [];\n\n    for (y = 0; y < la; y++) {\n      vector.push(y + 1);\n      vector.push(a.charCodeAt(offset + y));\n    }\n\n    var len = vector.length - 1;\n\n    for (; x < lb - 3;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      bx1 = b.charCodeAt(offset + (d1 = x + 1));\n      bx2 = b.charCodeAt(offset + (d2 = x + 2));\n      bx3 = b.charCodeAt(offset + (d3 = x + 3));\n      dd = (x += 4);\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        ay = vector[y + 1];\n        d0 = _min(dy, d0, d1, bx0, ay);\n        d1 = _min(d0, d1, d2, bx1, ay);\n        d2 = _min(d1, d2, d3, bx2, ay);\n        dd = _min(d2, d3, dd, bx3, ay);\n        vector[y] = dd;\n        d3 = d2;\n        d2 = d1;\n        d1 = d0;\n        d0 = dy;\n      }\n    }\n\n    for (; x < lb;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      dd = ++x;\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n        d0 = dy;\n      }\n    }\n\n    return dd;\n  };\n})();\n\nconst MAX_MATCH_SCORE = 3;\r\nconst MAX_SUGGESTION_COUNT = 4;\r\nconst TYPE_MATCH_DELTA = 0.5;\r\nfunction groupHandlersByType(handlers) {\r\n    return handlers.reduce((groups, handler) => {\r\n        if (handler instanceof RestHandler) {\r\n            groups.rest.push(handler);\r\n        }\r\n        if (handler instanceof GraphQLHandler) {\r\n            groups.graphql.push(handler);\r\n        }\r\n        return groups;\r\n    }, {\r\n        rest: [],\r\n        graphql: [],\r\n    });\r\n}\r\nfunction getRestHandlerScore() {\r\n    return (request, handler) => {\r\n        const { path, method } = handler.info;\r\n        if (path instanceof RegExp || method instanceof RegExp) {\r\n            return Infinity;\r\n        }\r\n        const hasSameMethod = isStringEqual(request.method, method);\r\n        // Always treat a handler with the same method as a more similar one.\r\n        const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\r\n        const requestPublicUrl = getPublicUrlFromRequest(request);\r\n        const score = jsLevenshtein(requestPublicUrl, path);\r\n        return score - methodScoreDelta;\r\n    };\r\n}\r\nfunction getGraphQLHandlerScore(parsedQuery) {\r\n    return (_, handler) => {\r\n        if (typeof parsedQuery.operationName === 'undefined') {\r\n            return Infinity;\r\n        }\r\n        const { operationType, operationName } = handler.info;\r\n        if (typeof operationName !== 'string') {\r\n            return Infinity;\r\n        }\r\n        const hasSameOperationType = parsedQuery.operationType === operationType;\r\n        // Always treat a handler with the same operation type as a more similar one.\r\n        const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\r\n        const score = jsLevenshtein(parsedQuery.operationName, operationName);\r\n        return score - operationTypeScoreDelta;\r\n    };\r\n}\r\nfunction getSuggestedHandler(request, handlers, getScore) {\r\n    const suggestedHandlers = handlers\r\n        .reduce((suggestions, handler) => {\r\n        const score = getScore(request, handler);\r\n        return suggestions.concat([[score, handler]]);\r\n    }, [])\r\n        .sort(([leftScore], [rightScore]) => leftScore - rightScore)\r\n        .filter(([score]) => score <= MAX_MATCH_SCORE)\r\n        .slice(0, MAX_SUGGESTION_COUNT)\r\n        .map(([, handler]) => handler);\r\n    return suggestedHandlers;\r\n}\r\nfunction getSuggestedHandlersMessage(handlers) {\r\n    if (handlers.length > 1) {\r\n        return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`;\r\n    }\r\n    return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\r\n}\r\nfunction onUnhandledRequest(request, handlers, strategy = 'warn') {\r\n    const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\r\n    function generateHandlerSuggestion() {\r\n        /**\r\n         * @note Ignore exceptions during GraphQL request parsing because at this point\r\n         * we cannot assume the unhandled request is a valid GraphQL request.\r\n         * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\r\n         */\r\n        const handlerGroups = groupHandlersByType(handlers);\r\n        const relevantHandlers = parsedGraphQLQuery\r\n            ? handlerGroups.graphql\r\n            : handlerGroups.rest;\r\n        const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery\r\n            ? getGraphQLHandlerScore(parsedGraphQLQuery)\r\n            : getRestHandlerScore());\r\n        return suggestedHandlers.length > 0\r\n            ? getSuggestedHandlersMessage(suggestedHandlers)\r\n            : '';\r\n    }\r\n    function generateUnhandledRequestMessage() {\r\n        const publicUrl = getPublicUrlFromRequest(request);\r\n        const requestHeader = parsedGraphQLQuery\r\n            ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\r\n            : `${request.method} ${publicUrl}`;\r\n        const handlerSuggestion = generateHandlerSuggestion();\r\n        const messageTemplate = [\r\n            `captured a request without a matching request handler:`,\r\n            `  \\u2022 ${requestHeader}`,\r\n            handlerSuggestion,\r\n            `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\r\n        ].filter(Boolean);\r\n        return messageTemplate.join('\\n\\n');\r\n    }\r\n    function applyStrategy(strategy) {\r\n        // Generate handler suggestions only when applying the strategy.\r\n        // This saves bandwidth for scenarios when developers opt-out\r\n        // from the default unhandled request handling strategy.\r\n        const message = generateUnhandledRequestMessage();\r\n        switch (strategy) {\r\n            case 'error': {\r\n                // Print a developer-friendly error.\r\n                devUtils.error('Error: %s', message);\r\n                // Throw an exception to halt request processing and not perform the original request.\r\n                throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\r\n            }\r\n            case 'warn': {\r\n                devUtils.warn('Warning: %s', message);\r\n                break;\r\n            }\r\n            case 'bypass':\r\n                break;\r\n            default:\r\n                throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy));\r\n        }\r\n    }\r\n    if (typeof strategy === 'function') {\r\n        strategy(request, {\r\n            warning: applyStrategy.bind(null, 'warn'),\r\n            error: applyStrategy.bind(null, 'error'),\r\n        });\r\n        return;\r\n    }\r\n    applyStrategy(strategy);\r\n}\n\nfunction readResponseCookies(request, response) {\r\n    store.add(Object.assign(Object.assign({}, request), { url: request.url.toString() }), response);\r\n    store.persist();\r\n}\n\nfunction handleRequest(request, handlers, options, emitter, handleRequestOptions) {\r\n    var _a, _b, _c;\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        emitter.emit('request:start', request);\r\n        // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\r\n        if (request.headers.get('x-msw-bypass') === 'true') {\r\n            emitter.emit('request:end', request);\r\n            (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, request);\r\n            return;\r\n        }\r\n        // Resolve a mocked response from the list of request handlers.\r\n        const lookupResult = yield getResponse(request, handlers, handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.resolutionContext);\r\n        const { handler, response } = lookupResult;\r\n        // When there's no handler for the request, consider it unhandled.\r\n        // Allow the developer to react to such cases.\r\n        if (!handler) {\r\n            onUnhandledRequest(request, handlers, options.onUnhandledRequest);\r\n            emitter.emit('request:unhandled', request);\r\n            emitter.emit('request:end', request);\r\n            (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, request);\r\n            return;\r\n        }\r\n        // When the handled request returned no mocked response, warn the developer,\r\n        // as it may be an oversight on their part. Perform the request as-is.\r\n        if (!response) {\r\n            devUtils.warn(`\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`, response, handler.info.header, handler.info.callFrame);\r\n            emitter.emit('request:end', request);\r\n            (_c = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _c === void 0 ? void 0 : _c.call(handleRequestOptions, request);\r\n            return;\r\n        }\r\n        // Store all the received response cookies in the virtual cookie store.\r\n        readResponseCookies(request, response);\r\n        emitter.emit('request:match', request);\r\n        return new Promise((resolve) => {\r\n            var _a, _b, _c;\r\n            const requiredLookupResult = lookupResult;\r\n            const transformedResponse = ((_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.transformResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, response)) ||\r\n                response;\r\n            (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, transformedResponse, requiredLookupResult);\r\n            setTimeout(() => {\r\n                var _a;\r\n                (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponseSent) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, transformedResponse, requiredLookupResult);\r\n                emitter.emit('request:end', request);\r\n                resolve(transformedResponse);\r\n            }, (_c = response.delay) !== null && _c !== void 0 ? _c : 0);\r\n        });\r\n    });\r\n}\n\nconst createRequestListener = (context, options) => {\r\n    return (event, message) => __awaiter(void 0, void 0, void 0, function* () {\r\n        const channel = createBroadcastChannel(event);\r\n        try {\r\n            const request = parseWorkerRequest(message.payload);\r\n            yield handleRequest(request, context.requestHandlers, options, context.emitter, {\r\n                transformResponse(response) {\r\n                    return Object.assign(Object.assign({}, response), { headers: response.headers.all() });\r\n                },\r\n                onBypassResponse() {\r\n                    return channel.send({\r\n                        type: 'MOCK_NOT_FOUND',\r\n                    });\r\n                },\r\n                onMockedResponse(response) {\r\n                    channel.send({\r\n                        type: 'MOCK_SUCCESS',\r\n                        payload: response,\r\n                    });\r\n                },\r\n                onMockedResponseSent(response, { handler, publicRequest, parsedRequest }) {\r\n                    if (!options.quiet) {\r\n                        handler.log(publicRequest, response, handler, parsedRequest);\r\n                    }\r\n                },\r\n            });\r\n        }\r\n        catch (error) {\r\n            if (error instanceof NetworkError) {\r\n                // Treat emulated network error differently,\r\n                // as it is an intended exception in a request handler.\r\n                return channel.send({\r\n                    type: 'NETWORK_ERROR',\r\n                    payload: {\r\n                        name: error.name,\r\n                        message: error.message,\r\n                    },\r\n                });\r\n            }\r\n            // Treat all the other exceptions in a request handler\r\n            // as unintended, alerting that there is a problem needs fixing.\r\n            channel.send({\r\n                type: 'INTERNAL_ERROR',\r\n                payload: {\r\n                    status: 500,\r\n                    body: JSON.stringify({\r\n                        errorType: error.constructor.name,\r\n                        message: error.message,\r\n                        location: error.stack,\r\n                    }),\r\n                },\r\n            });\r\n        }\r\n    });\r\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // Signal Service Worker to report back its integrity\r\n        context.workerChannel.send('INTEGRITY_CHECK_REQUEST');\r\n        const { payload: actualChecksum } = yield context.events.once('INTEGRITY_CHECK_RESPONSE');\r\n        // Compare the response from the Service Worker and the\r\n        // global variable set by Rollup during the build.\r\n        if (actualChecksum !== \"02f4ad4a2797f85668baf196e553d929\") {\r\n            throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"02f4ad4a2797f85668baf196e553d929\"}).`);\r\n        }\r\n        return serviceWorker;\r\n    });\r\n}\n\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\r\nfunction deferNetworkRequestsUntil(predicatePromise) {\r\n    // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\r\n    const originalXhrSend = window.XMLHttpRequest.prototype.send;\r\n    window.XMLHttpRequest.prototype.send = function (...args) {\r\n        // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\r\n        // because that method is always synchronous.\r\n        until(() => predicatePromise).then(() => {\r\n            window.XMLHttpRequest.prototype.send = originalXhrSend;\r\n            this.send(...args);\r\n        });\r\n    };\r\n    // Defer any `fetch` requests until the Service Worker is ready.\r\n    const originalFetch = window.fetch;\r\n    window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {\r\n        yield until(() => predicatePromise);\r\n        window.fetch = originalFetch;\r\n        return window.fetch(...args);\r\n    });\r\n}\n\nfunction createResponseListener(context) {\r\n    return (_, message) => {\r\n        var _a;\r\n        const { payload: responseJson } = message;\r\n        /**\r\n         * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\r\n         * That kind of responses cannot be manipulated in JavaScript due\r\n         * to the security considerations.\r\n         * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\r\n         * @see https://github.com/mswjs/msw/issues/529\r\n         */\r\n        if ((_a = responseJson.type) === null || _a === void 0 ? void 0 : _a.includes('opaque')) {\r\n            return;\r\n        }\r\n        const response = new Response(responseJson.body || null, responseJson);\r\n        const isMockedResponse = response.headers.get('x-powered-by') === 'msw';\r\n        if (isMockedResponse) {\r\n            context.emitter.emit('response:mocked', response, responseJson.requestId);\r\n        }\r\n        else {\r\n            context.emitter.emit('response:bypass', response, responseJson.requestId);\r\n        }\r\n    };\r\n}\n\nfunction validateWorkerScope(registration, options) {\r\n    if (!(options === null || options === void 0 ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\r\n        devUtils.warn(`\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`);\r\n    }\r\n}\n\nconst createStartHandler = (context) => {\r\n    return function start(options, customOptions) {\r\n        const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {\r\n            // Remove all previously existing event listeners.\r\n            // This way none of the listeners persists between Fast refresh\r\n            // of the application's code.\r\n            context.events.removeAllListeners();\r\n            // Handle requests signaled by the worker.\r\n            context.workerChannel.on('REQUEST', createRequestListener(context, options));\r\n            context.workerChannel.on('RESPONSE', createResponseListener(context));\r\n            const instance = yield getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\r\n            const [worker, registration] = instance;\r\n            if (!worker) {\r\n                const missingWorkerMessage = (customOptions === null || customOptions === void 0 ? void 0 : customOptions.findWorker)\r\n                    ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url)\r\n                    : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\r\n                throw new Error(missingWorkerMessage);\r\n            }\r\n            context.worker = worker;\r\n            context.registration = registration;\r\n            context.events.addListener(window, 'beforeunload', () => {\r\n                if (worker.state !== 'redundant') {\r\n                    // Notify the Service Worker that this client has closed.\r\n                    // Internally, it's similar to disabling the mocking, only\r\n                    // client close event has a handler that self-terminates\r\n                    // the Service Worker when there are no open clients.\r\n                    context.workerChannel.send('CLIENT_CLOSED');\r\n                }\r\n                // Make sure we're always clearing the interval - there are reports that not doing this can\r\n                // cause memory leaks in headless browser environments.\r\n                window.clearInterval(context.keepAliveInterval);\r\n            });\r\n            // Check if the active Service Worker is the latest published one\r\n            const [integrityError] = yield until(() => requestIntegrityCheck(context, worker));\r\n            if (integrityError) {\r\n                devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `);\r\n            }\r\n            context.keepAliveInterval = window.setInterval(() => context.workerChannel.send('KEEPALIVE_REQUEST'), 5000);\r\n            // Warn the user when loading the page that lies outside\r\n            // of the worker's scope.\r\n            validateWorkerScope(registration, context.startOptions);\r\n            return registration;\r\n        });\r\n        const workerRegistration = startWorkerInstance().then((registration) => __awaiter(this, void 0, void 0, function* () {\r\n            const pendingInstance = registration.installing || registration.waiting;\r\n            // Wait until the worker is activated.\r\n            // Assume the worker is already activated if there's no pending registration\r\n            // (i.e. when reloading the page after a successful activation).\r\n            if (pendingInstance) {\r\n                yield new Promise((resolve) => {\r\n                    pendingInstance.addEventListener('statechange', () => {\r\n                        if (pendingInstance.state === 'activated') {\r\n                            return resolve();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            // Print the activation message only after the worker has been activated.\r\n            yield enableMocking(context, options).catch((error) => {\r\n                throw new Error(`Failed to enable mocking: ${error === null || error === void 0 ? void 0 : error.message}`);\r\n            });\r\n            return registration;\r\n        }));\r\n        // Defer any network requests until the Service Worker instance is ready.\r\n        // This prevents a race condition between the Service Worker registration\r\n        // and application's runtime requests (i.e. requests on mount).\r\n        if (options.waitUntilReady) {\r\n            deferNetworkRequestsUntil(workerRegistration);\r\n        }\r\n        return workerRegistration;\r\n    };\r\n};\n\nfunction printStopMessage(args = {}) {\r\n    if (args.quiet) {\r\n        return;\r\n    }\r\n    console.log(`%c${devUtils.formatMessage('Mocking disabled.')}`, 'color:orangered;font-weight:bold;');\r\n}\n\nconst createStop = (context) => {\r\n    return function stop() {\r\n        var _a;\r\n        /**\r\n         * Signal the Service Worker to disable mocking for this client.\r\n         * Use this an an explicit way to stop the mocking, while preserving\r\n         * the worker-client relation. Does not affect the worker's lifecycle.\r\n         */\r\n        context.workerChannel.send('MOCK_DEACTIVATE');\r\n        window.clearInterval(context.keepAliveInterval);\r\n        printStopMessage({ quiet: (_a = context.startOptions) === null || _a === void 0 ? void 0 : _a.quiet });\r\n    };\r\n};\n\nfunction use(currentHandlers, ...handlers) {\r\n    currentHandlers.unshift(...handlers);\r\n}\r\nfunction restoreHandlers(handlers) {\r\n    handlers.forEach((handler) => {\r\n        handler.markAsSkipped(false);\r\n    });\r\n}\r\nfunction resetHandlers(initialHandlers, ...nextHandlers) {\r\n    return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\r\n}\n\nconst DEFAULT_START_OPTIONS = {\r\n    serviceWorker: {\r\n        url: '/mockServiceWorker.js',\r\n        options: null,\r\n    },\r\n    quiet: false,\r\n    waitUntilReady: true,\r\n    onUnhandledRequest: 'warn',\r\n    findWorker(scriptURL, mockServiceWorkerUrl) {\r\n        return scriptURL === mockServiceWorkerUrl;\r\n    },\r\n};\r\n/**\r\n * Returns resolved worker start options, merging the default options\r\n * with the given custom options.\r\n */\r\nfunction resolveStartOptions(initialOptions) {\r\n    return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\r\n}\r\nfunction prepareStartHandler(handler, context) {\r\n    return (initialOptions) => {\r\n        context.startOptions = resolveStartOptions(initialOptions);\r\n        return handler(context.startOptions, initialOptions || {});\r\n    };\r\n}\n\n/**\r\n * Converts a given isomorphic request to a `MockedRequest` instance.\r\n */\r\nfunction parseIsomorphicRequest(request) {\r\n    const mockedRequest = {\r\n        id: request.id,\r\n        url: request.url,\r\n        method: request.method,\r\n        body: parseBody(request.body, request.headers),\r\n        credentials: request.credentials || 'same-origin',\r\n        headers: request.headers,\r\n        cookies: {},\r\n        redirect: 'manual',\r\n        referrer: '',\r\n        keepalive: false,\r\n        cache: 'default',\r\n        mode: 'cors',\r\n        referrerPolicy: 'no-referrer',\r\n        integrity: '',\r\n        destination: 'document',\r\n        bodyUsed: false,\r\n    };\r\n    // Attach all the cookies from the virtual cookie store.\r\n    setRequestCookies(mockedRequest);\r\n    return mockedRequest;\r\n}\n\nfunction createFallbackRequestListener(context, options) {\r\n    const interceptor = createInterceptor({\r\n        modules: [interceptFetch, interceptXMLHttpRequest],\r\n        resolver(request) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                const mockedRequest = parseIsomorphicRequest(request);\r\n                return handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\r\n                    transformResponse(response) {\r\n                        return {\r\n                            status: response.status,\r\n                            statusText: response.statusText,\r\n                            headers: response.headers.all(),\r\n                            body: response.body,\r\n                        };\r\n                    },\r\n                    onMockedResponseSent(response, { handler, publicRequest, parsedRequest }) {\r\n                        if (!options.quiet) {\r\n                            handler.log(publicRequest, response, handler, parsedRequest);\r\n                        }\r\n                    },\r\n                });\r\n            });\r\n        },\r\n    });\r\n    interceptor.apply();\r\n    return interceptor;\r\n}\n\nfunction createFallbackStart(context) {\r\n    return function start(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            context.fallbackInterceptor = createFallbackRequestListener(context, options);\r\n            printStartMessage({\r\n                message: 'Mocking enabled (fallback mode).',\r\n                quiet: options.quiet,\r\n            });\r\n            return undefined;\r\n        });\r\n    };\r\n}\n\nfunction createFallbackStop(context) {\r\n    return function stop() {\r\n        var _a, _b;\r\n        (_a = context.fallbackInterceptor) === null || _a === void 0 ? void 0 : _a.restore();\r\n        printStopMessage({ quiet: (_b = context.startOptions) === null || _b === void 0 ? void 0 : _b.quiet });\r\n    };\r\n}\n\n/**\r\n * Pipes all emitted events from one emitter to another.\r\n */\r\nfunction pipeEvents(source, destination) {\r\n    const rawEmit = source.emit;\r\n    // @ts-ignore\r\n    if (rawEmit._isPiped) {\r\n        return;\r\n    }\r\n    source.emit = function (event, ...data) {\r\n        destination.emit(event, ...data);\r\n        return rawEmit.call(this, event, ...data);\r\n    };\r\n    // @ts-ignore\r\n    source.emit._isPiped = true;\r\n}\n\n// Declare the list of event handlers on the module's scope\r\n// so it persists between Fash refreshes of the application's code.\r\nlet listeners = [];\r\n/**\r\n * Creates a new mock Service Worker registration\r\n * with the given request handlers.\r\n * @param {RequestHandler[]} requestHandlers List of request handlers\r\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\r\n */\r\nfunction setupWorker(...requestHandlers) {\r\n    requestHandlers.forEach((handler) => {\r\n        if (Array.isArray(handler))\r\n            throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\r\n    });\r\n    // Error when attempting to run this function in a Node.js environment.\r\n    if (lib$3.exports.isNodeProcess()) {\r\n        throw new Error(devUtils.formatMessage('Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.'));\r\n    }\r\n    const emitter = new lib$1.StrictEventEmitter();\r\n    const publicEmitter = new lib$1.StrictEventEmitter();\r\n    pipeEvents(emitter, publicEmitter);\r\n    const context = {\r\n        startOptions: undefined,\r\n        worker: null,\r\n        registration: null,\r\n        requestHandlers: [...requestHandlers],\r\n        emitter,\r\n        workerChannel: {\r\n            on(eventType, callback) {\r\n                context.events.addListener(navigator.serviceWorker, 'message', (event) => {\r\n                    // Avoid messages broadcasted from unrelated workers.\r\n                    if (event.source !== context.worker) {\r\n                        return;\r\n                    }\r\n                    const message = jsonParse(event.data);\r\n                    if (!message) {\r\n                        return;\r\n                    }\r\n                    if (message.type === eventType) {\r\n                        callback(event, message);\r\n                    }\r\n                });\r\n            },\r\n            send(type) {\r\n                var _a;\r\n                (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage(type);\r\n            },\r\n        },\r\n        events: {\r\n            addListener(target, eventType, callback) {\r\n                target.addEventListener(eventType, callback);\r\n                listeners.push({ eventType, target, callback });\r\n                return () => {\r\n                    target.removeEventListener(eventType, callback);\r\n                };\r\n            },\r\n            removeAllListeners() {\r\n                for (const { target, eventType, callback } of listeners) {\r\n                    target.removeEventListener(eventType, callback);\r\n                }\r\n                listeners = [];\r\n            },\r\n            once(eventType) {\r\n                const bindings = [];\r\n                return new Promise((resolve, reject) => {\r\n                    const handleIncomingMessage = (event) => {\r\n                        try {\r\n                            const message = JSON.parse(event.data);\r\n                            if (message.type === eventType) {\r\n                                resolve(message);\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            reject(error);\r\n                        }\r\n                    };\r\n                    bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\r\n                }).finally(() => {\r\n                    bindings.forEach((unbind) => unbind());\r\n                });\r\n            },\r\n        },\r\n        useFallbackMode: !('serviceWorker' in navigator) || location.protocol === 'file:',\r\n    };\r\n    const startHandler = context.useFallbackMode\r\n        ? createFallbackStart(context)\r\n        : createStartHandler(context);\r\n    const stopHandler = context.useFallbackMode\r\n        ? createFallbackStop(context)\r\n        : createStop(context);\r\n    return {\r\n        start: prepareStartHandler(startHandler, context),\r\n        stop() {\r\n            context.events.removeAllListeners();\r\n            context.emitter.removeAllListeners();\r\n            publicEmitter.removeAllListeners();\r\n            stopHandler();\r\n        },\r\n        use(...handlers) {\r\n            use(context.requestHandlers, ...handlers);\r\n        },\r\n        restoreHandlers() {\r\n            restoreHandlers(context.requestHandlers);\r\n        },\r\n        resetHandlers(...nextHandlers) {\r\n            context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\r\n        },\r\n        printHandlers() {\r\n            context.requestHandlers.forEach((handler) => {\r\n                const { header, callFrame } = handler.info;\r\n                const pragma = handler.info.hasOwnProperty('operationType')\r\n                    ? '[graphql]'\r\n                    : '[rest]';\r\n                console.groupCollapsed(`${pragma} ${header}`);\r\n                if (callFrame) {\r\n                    console.log(`Declaration: ${callFrame}`);\r\n                }\r\n                console.log('Handler:', handler);\r\n                if (handler instanceof RestHandler) {\r\n                    console.log('Match:', `https://mswjs.io/repl?path=${handler.info.path}`);\r\n                }\r\n                console.groupEnd();\r\n            });\r\n        },\r\n        events: {\r\n            on(...args) {\r\n                return publicEmitter.on(...args);\r\n            },\r\n            removeListener(...args) {\r\n                return publicEmitter.removeListener(...args);\r\n            },\r\n            removeAllListeners(...args) {\r\n                return publicEmitter.removeAllListeners(...args);\r\n            },\r\n        },\r\n    };\r\n}\n\nexport { handleRequest, parseIsomorphicRequest, setupWorker };\n"]},"metadata":{},"sourceType":"module"}